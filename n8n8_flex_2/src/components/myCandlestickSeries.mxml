<?xml version="1.0" encoding="utf-8"?>
<mx:CandlestickSeries xmlns:fx="http://ns.adobe.com/mxml/2009" creationComplete="init()"
					  xmlns:s="library://ns.adobe.com/flex/spark" filterData="false"
					  xmlns:mx="library://ns.adobe.com/flex/mx">
	<fx:Declarations>
		<!-- X Y 坐标提示 -->
		<mx:HBox id="xTips" backgroundColor="0xFF0000" width="110" height="22" visible="{isShow}">
			<mx:Label id="xText" color="white" paddingBottom="4" paddingLeft="4" fontWeight="bold" fontSize="12"
					  paddingRight="4" paddingTop="4" text="---"/>
		</mx:HBox>
		
		<mx:HBox id="yTips" backgroundColor="0xFF0000" width="60" height="22" visible="{isShow}">
			<mx:Label id="yText" color="white"  paddingBottom="4" paddingLeft="4" textAlign="right" fontSize="12" fontWeight="bold"
					   paddingTop="4" text="-------"/>
		</mx:HBox>
		<mx:DateFormatter id="DD" formatString="YYYY-MM-DD 周EEE"/>
	</fx:Declarations>
	<fx:Metadata>
		[Event(name="drawLined", type="flash.events.Event")]
		[Event(name="clearLine", type="flash.events.Event")]

	</fx:Metadata>
	<fx:Script>
		<![CDATA[
			import mx.charts.series.items.HLOCSeriesItem;

			use namespace mx_internal;

			//捕获光标坐标
			public var currX:Number;
			//光标下对应的item index
			public var currIndex:uint;
			
			public var lineStyle:String = 'line';
			public var startX:Number = 0;
			
			[Bindable]
			private var isShow:Boolean = false;
			
			public function showCusor():void
			{
				isShow = ! isShow;
				
				if( ! isShow )
				{
					this.dispatchEvent( new Event('clearLine'));
				}
				
				refresh_cusor();
			}
			
			private function refresh_cusor():void
			{
				if( ! isShow )
				{
					this.graphics.clear();
					return;
				}
				
				if( lineStyle === 'line')
				{
					this.graphics.clear();
					this.graphics.lineStyle( 1 , 0xffffff);
					
					//垂直
					this.graphics.moveTo( currX, 0);
					this.graphics.lineTo( currX , this.height);
					
					//水平
					this.graphics.moveTo( 0 , this.mouseY );
					this.graphics.lineTo( this.width , this.mouseY );
					
					this.dispatchEvent( new Event('drawLined'));
				}
				else if( lineStyle === 'block' )
				{
					this.graphics.clear();
					this.graphics.beginFill( 0xA63232 , 0.6 );
					this.graphics.drawRect( startX , 0 , currX - startX , this.height );
					this.graphics.endFill();
				}
			}
			
			private function init():void
			{
				this.addChild(xTips);
				this.addChild(yTips);
			}
			
			override public function findDataPoints(x:Number,y:Number,sensitivity:Number):Array /* of HitData */
			{

				if ( ! interactive || !_renderData)
					return [];
				
				
				var minDist:Number = _renderData.renderedHalfWidth + sensitivity;
				var minItem:HLOCSeriesItem;     
				
				var n:uint = _renderData.filteredCache.length;
				var i:uint;
				
				//var test:Number = (_renderData.renderedHalfWidth * 2 * n) + Math.abs((_renderData.renderedXOffset*(n+1)*2));

				
				for (i = 0; i < n; i++)
				{
					var v:HLOCSeriesItem = _renderData.filteredCache[i];
					
					var dist:Number = Math.abs((v.x + _renderData.renderedXOffset) - x);
					//var dist:Number = (v.x  - x)*(v.x  - x) + (v.close - y)*(v.close -y);
					if (dist > minDist)
						continue;

					minDist = dist;
					minItem = v;
					if (dist < _renderData.renderedHalfWidth)
					{
						// we're actually inside the column, so go no further.
						break;
					}
				}
				
				if (minItem)
				{
					currX = minItem.x;
					
					if( currX > 110 && currX+110 < this.width)
					{
						xTips.x = currX-55;
					}
					else if(currX+110 >  this.width)
					{
						xTips.x = currX-110;
					}
					else
					{
						xTips.x = currX;
					}
					
					xTips.y = this.height - 22;
					xText.text = DD.format( new Date( minItem.item.Date ) ) ;
					
					yTips.x = this.width - 60;
					if( this.mouseY + 22 < this.height )
						yTips.y = this.mouseY;
					else
						yTips.y = this.mouseY-22;
					
					yText.text = this.localToData(new Point( 0 , this.mouseY ) )[1].toFixed(2);
					
					this.refresh_cusor();

					currIndex = minItem.index;

					return [];
				}
				return [];
			}
			
		]]>
	</fx:Script>
	
	
</mx:CandlestickSeries>
